{{/* ConfigMap containing the log collector script */}}
{{- $pxBackupEnabled := .Values.pxbackup.enabled | default false }}
{{- $telemetryEnabled := .Values.pxbackup.telemetry.enabled | default false }}
{{- if and $pxBackupEnabled $telemetryEnabled }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: px-backup-log-collector-script
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: px-backup-telemetry
    app.kubernetes.io/component: log-collector
{{- include "px-central.labels" . | nindent 4 }}
data:
  collect-logs.sh: |
    #!/bin/bash
    #
    # PX-Backup Log Collector Script
    # 
    # This script collects logs from PX-Backup pods and writes them to /var/cores/
    # for PX-Enterprise phonehome to upload to Pure1.
    #
    # File naming pattern: px-backup-diags-<timestamp>.log.gz
    # This matches the phonehome pattern: /var/cores/*diags*
    #

    set -e

    # Configuration
    NAMESPACE="${NAMESPACE:-px-backup}"
    POD_LABEL="${POD_LABEL:-app=px-backup}"
    LOG_DIR="${LOG_DIR:-/var/cores}"
    COLLECTION_INTERVAL="${COLLECTION_INTERVAL:-3600}"  # 1 hour in seconds
    LOG_SINCE="${LOG_SINCE:-3600s}"  # Collect logs from last 1 hour

    # Logging functions
    log_info() {
        echo "$(date '+%Y-%m-%d %H:%M:%S'): $*"
    }

    log_error() {
        echo "$(date '+%Y-%m-%d %H:%M:%S'): ERROR: $*" >&2
    }

    # Check if kubectl is available
    if ! command -v kubectl &> /dev/null; then
        log_error "kubectl not found in PATH"
        exit 1
    fi

    log_info "Starting PX-Backup log collector..."
    log_info "Namespace: $NAMESPACE"
    log_info "Pod Label: $POD_LABEL"
    log_info "Log Directory: $LOG_DIR"
    log_info "Collection Interval: ${COLLECTION_INTERVAL}s"

    # Main loop
    while true; do
      # Generate timestamp (14-digit format: YYYYMMDDHHmmss)
      TIMESTAMP=$(date +%Y%m%d%H%M%S)
      LOG_FILE="${LOG_DIR}/px-backup-diags-${TIMESTAMP}.log"
      
      log_info "Collecting logs with timestamp ${TIMESTAMP}"
      
      # Get all PX-Backup pods
      PODS=$(kubectl get pods -n "$NAMESPACE" -l "$POD_LABEL" -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)
      
      if [ -z "$PODS" ]; then
        log_error "No pods found with label $POD_LABEL in namespace $NAMESPACE"
      else
        # Collect logs from each pod
        for POD in $PODS; do
          echo "=== Logs from pod: $POD ===" >> "$LOG_FILE" 2>&1
          echo "Timestamp: $(date)" >> "$LOG_FILE" 2>&1
          echo "" >> "$LOG_FILE" 2>&1
          
          # Get logs from the pod (last hour)
          kubectl logs -n "$NAMESPACE" "$POD" --since="$LOG_SINCE" >> "$LOG_FILE" 2>&1 || {
            echo "Failed to get logs from pod $POD" >> "$LOG_FILE" 2>&1
          }
          
          echo "" >> "$LOG_FILE" 2>&1
          echo "=== End of logs from pod: $POD ===" >> "$LOG_FILE" 2>&1
          echo "" >> "$LOG_FILE" 2>&1
        done
        
        # Compress the log file
        if [ -f "$LOG_FILE" ]; then
          gzip -f "$LOG_FILE"
          
          # Get file size (works on both Linux and macOS)
          if command -v stat &> /dev/null; then
            FILE_SIZE=$(stat -f%z "${LOG_FILE}.gz" 2>/dev/null || stat -c%s "${LOG_FILE}.gz" 2>/dev/null || echo "unknown")
          else
            FILE_SIZE="unknown"
          fi
          
          log_info "Created: ${LOG_FILE}.gz (${FILE_SIZE} bytes)"
        else
          log_error "Log file was not created: $LOG_FILE"
        fi
      fi
      
      # Sleep for the configured interval
      log_info "Sleeping for ${COLLECTION_INTERVAL}s..."
      sleep "$COLLECTION_INTERVAL"
    done
{{- end }}

