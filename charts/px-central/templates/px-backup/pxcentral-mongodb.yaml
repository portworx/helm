{{/* Setting defaults if they are omitted. */}}
{{- $pxBackupEnabled := .Values.pxbackup.enabled | default false }}
{{- $externalPersistentStorageEnabled := .Values.persistentStorage.enabled | default false }}
{{- $isOpenshiftCluster := or .Values.isOpenshift (.Capabilities.APIVersions.Has "apps.openshift.io/v1") -}}
{{- $mongoCacheSize := int .Values.persistentStorage.mongoCacheSize}}
{{- $azureProxyEnabled := .Values.proxy.azureProxyEnabled | default false }}
{{- if eq $pxBackupEnabled true }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: pxc-backup-mongodb-scripts
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/component: pxc-backup-mongodb
  {{- include "px-central.labels" . | nindent 4 }}
data:
  setup.sh: |-
    #!/bin/bash
    set -e

    echo "Advertised Hostname: $MONGODB_ADVERTISED_HOSTNAME"
    echo "Advertised Service: $K8S_SERVICE_NAME"

    # Wait until all peers are resolvable via DNS
    for i in 0 1 2; do
      host="pxc-backup-mongodb-$i.pxc-backup-mongodb-headless"
      echo "Waiting for DNS resolution of $host..."
      until getent hosts $host > /dev/null; do
        sleep 3
      done
    done

    # Check for existing replica set (always check, not just when data dir is empty)
    # This handles:
    # 1. Fresh install: data dir empty, no primary exists yet
    # 2. Pod restart with existing data: need to detect if another pod became primary
    # 3. PVC recovery: data dir empty, but replica set exists
    current_primary=""
    mongoList="pxc-backup-mongodb-0.pxc-backup-mongodb-headless:27017,pxc-backup-mongodb-1.pxc-backup-mongodb-headless:27017,pxc-backup-mongodb-2.pxc-backup-mongodb-headless:27017"
    echo "Checking for existing primary..."
    current_primary=$(mongosh admin --host "$mongoList" --authenticationDatabase admin -u root -p "$MONGODB_ROOT_PASSWORD" \
      --eval 'try { isMaster = db.runCommand("ismaster"); print(isMaster.primary); } catch (e) { print(""); }' --quiet | tail -n 1)

    if [ -n "$current_primary" ]; then
      echo "Detected existing primary: ${current_primary}"
    fi

    # Determine replica set mode
    if [ -n "$current_primary" ] && [[ "$MONGODB_ADVERTISED_HOSTNAME:27017" == "$current_primary" ]]; then
        echo "Advertised name matches current primary, configuring node as a primary"
        export MONGODB_REPLICA_SET_MODE="primary"
    elif [ -n "$current_primary" ] && [[ "$MONGODB_ADVERTISED_HOSTNAME:27017" != "$current_primary" ]]; then
        echo "Current primary is different from this node. Configuring the node as replica of ${current_primary}"
        export MONGODB_REPLICA_SET_MODE="secondary"
        export MONGODB_INITIAL_PRIMARY_HOST="$current_primary"
    elif [[ "$MY_POD_NAME" = "$(echo $MONGODB_INITIAL_PRIMARY_HOST | cut -d'.' -f1)" ]]; then
        echo "Pod name matches initial primary pod name, configuring node as a primary"
        export MONGODB_REPLICA_SET_MODE="primary"
    else
      export MONGODB_REPLICA_SET_MODE="secondary"
      # Safety net: If no primary detected, assume Pod-0 is the primary
      if [ -z "$MONGODB_INITIAL_PRIMARY_HOST" ]; then
        export MONGODB_INITIAL_PRIMARY_HOST="pxc-backup-mongodb-0.pxc-backup-mongodb-headless:27017"
        echo "No primary detected, defaulting to Pod-0 as initial primary"
      fi
    fi

    # Create MongoDB configuration file
    cat > /data/db/mongod.conf <<EOF
    net:
      port: 27017
      bindIp: 0.0.0.0
    replication:
      replSetName: ${MONGODB_REPLICA_SET_NAME}
    security:
      authorization: enabled
      keyFile: /tmp/replica.key
    storage:
      wiredTiger:
        engineConfig:
          cacheSizeGB: ${MONGODB_CACHE_SIZE}
    EOF

    # Setup replica set key with proper permissions from the start
    (
      umask 077
      echo "$MONGODB_REPLICA_SET_KEY" > /tmp/replica.key
    )

    # Verify and fix permissions if needed
    current_perms=$(stat -c "%a" /tmp/replica.key 2>/dev/null || echo "unknown")
    if [ "$current_perms" != "400" ] && [ "$current_perms" != "600" ]; then
        echo "Warning: replica.key has unexpected permissions: $current_perms"
        echo "Attempting to fix with chmod 400..."
        chmod 400 /tmp/replica.key 2>/dev/null || {
            echo "Warning: Could not set permissions on replica.key, continuing anyway (MongoDB may still work)"
        }
    fi

    # Change ownership to mongodb user
    chown mongodb:mongodb /tmp/replica.key 2>/dev/null || {
        echo "Warning: Could not change ownership of replica.key, continuing anyway"
    }

    # Initialize replica set if primary
    if [[ "$MONGODB_REPLICA_SET_MODE" == "primary" ]]; then
      echo "Starting MongoDB as primary..."

      # Check if already initialized
      if [ -f /data/db/initialized ]; then
        echo "MongoDB already initialized, starting normally..."
        exec mongod --config /data/db/mongod.conf
      fi

      # Start MongoDB without auth for initial setup (Bitnami-style bootstrap)
      mongod --bind_ip_all --replSet ${MONGODB_REPLICA_SET_NAME} --port 27017 --dbpath /data/db --fork --logpath /data/db/mongod.log

      # Wait for MongoDB to accept connections
      until mongosh --quiet --eval "db.adminCommand('ping')" > /dev/null 2>&1; do
        echo "Waiting for MongoDB to start..."
        sleep 2
      done

      # Initialize replica set with only this node (PRIMARY)
      mongosh admin --eval "
        rs.initiate({
          _id: '${MONGODB_REPLICA_SET_NAME}',
          members: [
            { _id: 0, host: '${MONGODB_ADVERTISED_HOSTNAME}:27017' }
          ]
        })
      " || true

      # Wait until this node is PRIMARY before creating users
      echo "Waiting to become PRIMARY..."
      TIMEOUT=300
      ELAPSED=0
      until mongosh --quiet --eval 'db.hello().isWritablePrimary' | grep -q '^true$'; do
        ELAPSED=$((ELAPSED + 2))
        if [ $ELAPSED -gt $TIMEOUT ]; then
          echo "ERROR: Primary election timeout after $TIMEOUT seconds"
          exit 1
        fi
        sleep 2
      done

      # Create root user if missing
      if ! mongosh admin --quiet --eval 'db.getUser("root") ? "EXISTS" : "MISSING"' | grep -q '^EXISTS$'; then
        mongosh admin --quiet --eval "db.createUser({user:'root',pwd:'${MONGODB_ROOT_PASSWORD}',roles:[{role:'root',db:'admin'}]})"
      fi

      # Create application user if provided (and missing)
      if [ -n "$MONGODB_USERNAME" ] && [ -n "$MONGODB_PASSWORD" ]; then
        if ! mongosh admin --quiet --eval "db.getSiblingDB('${MONGODB_DATABASE}').getUser('${MONGODB_USERNAME}') ? 'EXISTS' : 'MISSING'" | grep -q '^EXISTS$'; then
          mongosh admin --quiet --eval "db.getSiblingDB('${MONGODB_DATABASE}').createUser({user:'${MONGODB_USERNAME}',pwd:'${MONGODB_PASSWORD}',roles:[{role:'readWrite',db:'${MONGODB_DATABASE}'}]})"
        fi
      fi

      # Mark as initialized
      touch /data/db/initialized

      # Shutdown to restart with auth enabled
      mongosh admin --quiet --eval "db.shutdownServer()" || true
      sleep 3

      # Start with auth enabled (uses keyFile + authorization in mongod.conf)
      # Secondaries will add themselves to the replica set
      exec mongod --config /data/db/mongod.conf
    else
      # Secondary node - add itself to replica set (same pattern as PRIMARY)
      echo "Starting MongoDB as secondary..."

      # Check if already initialized
      if [ -f /data/db/initialized ]; then
        echo "MongoDB already initialized, starting normally..."
        exec mongod --config /data/db/mongod.conf
      fi

      # Extract primary host and port from MONGODB_INITIAL_PRIMARY_HOST
      if [[ "$MONGODB_INITIAL_PRIMARY_HOST" == *":"* ]]; then
        PRIMARY_HOST=$(echo $MONGODB_INITIAL_PRIMARY_HOST | cut -d':' -f1)
        PRIMARY_PORT=$(echo $MONGODB_INITIAL_PRIMARY_HOST | cut -d':' -f2)
      else
        PRIMARY_HOST=$MONGODB_INITIAL_PRIMARY_HOST
        PRIMARY_PORT=27017
      fi

      echo "Waiting for primary to be ready..."
      TIMEOUT=300
      ELAPSED=0
      until mongosh admin --host "$PRIMARY_HOST:$PRIMARY_PORT" -u root -p "$MONGODB_ROOT_PASSWORD" \
        --eval "db.adminCommand('ping')" --quiet > /dev/null 2>&1; do
        ELAPSED=$((ELAPSED + 3))
        if [ $ELAPSED -gt $TIMEOUT ]; then
          echo "ERROR: Primary not ready after $TIMEOUT seconds"
          exit 1
        fi
        echo "Primary not ready yet, waiting..."
        sleep 3
      done

      # Start MongoDB without auth for replica set addition (same as PRIMARY)
      echo "Starting MongoDB without auth for replica set addition..."
      mongod --bind_ip_all --replSet ${MONGODB_REPLICA_SET_NAME} --port 27017 --dbpath /data/db --fork --logpath /data/db/mongod.log

      # Wait for MongoDB to accept connections
      until mongosh --quiet --eval "db.adminCommand('ping')" > /dev/null 2>&1; do
        echo "Waiting for MongoDB to start..."
        sleep 2
      done

      # Try to add this node to replica set with exponential backoff retry
      echo "Attempting to add this node to replica set..."
      MAX_ATTEMPTS=10
      ATTEMPT=1
      WAIT_TIME=1
      SUCCESS=false

      while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
        echo "Attempt $ATTEMPT/$MAX_ATTEMPTS to add node to replica set..."

        if mongosh admin --host "$PRIMARY_HOST:$PRIMARY_PORT" -u root -p "$MONGODB_ROOT_PASSWORD" \
          --quiet --eval "rs.add('${MONGODB_ADVERTISED_HOSTNAME}:27017')" > /dev/null 2>&1; then
          echo "Successfully added to replica set"
          SUCCESS=true
          break
        else
          # Check if already in replica set
          if mongosh admin --host "$PRIMARY_HOST:$PRIMARY_PORT" -u root -p "$MONGODB_ROOT_PASSWORD" \
            --quiet --eval "rs.conf().members.find(m => m.host === '${MONGODB_ADVERTISED_HOSTNAME}:27017') ? 'YES' : 'NO'" | grep -q '^YES$'; then
            echo "Node already in replica set"
            SUCCESS=true
            break
          fi

          if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
            echo "Failed to add node, retrying in ${WAIT_TIME}s..."
            sleep $WAIT_TIME
            # Exponential backoff: 1s, 2s, 4s, 8s, etc.
            WAIT_TIME=$((WAIT_TIME * 2))
            if [ $WAIT_TIME -gt 32 ]; then
              WAIT_TIME=32
            fi
          fi
        fi

        ATTEMPT=$((ATTEMPT + 1))
      done

      if [ "$SUCCESS" != "true" ]; then
        echo "ERROR: Failed to add node to replica set after $MAX_ATTEMPTS attempts"
        exit 1
      fi

      # Mark as initialized
      touch /data/db/initialized

      # Shutdown to restart with auth enabled
      mongosh admin --quiet --eval "db.shutdownServer()" || true
      sleep 3

      # Start with auth enabled (uses keyFile + authorization in mongod.conf)
      echo "Restarting with auth enabled..."
      exec mongod --config /data/db/mongod.conf
    fi
---
apiVersion: v1
kind: Service
metadata:
  name: pxc-backup-mongodb-headless
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/component: pxc-backup-mongodb
{{- include "px-central.labels" . | nindent 4 }}
spec:
  type: ClusterIP
  clusterIP: None
  publishNotReadyAddresses: true
  ports:
    - name: mongodb
      port: 27017
      targetPort: mongodb
  selector:
    app.kubernetes.io/component: pxc-backup-mongodb
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: pxc-backup-mongodb
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/component: pxc-backup-mongodb
{{- include "px-central.labels" . | nindent 4 }}
secrets:
  - name: pxc-backup-mongodb
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: pxc-backup-mongodb
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/component: pxc-backup-mongodb
{{- include "px-central.labels" . | nindent 4 }}
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: {{.Release.Name }}
      app.kubernetes.io/instance: {{.Release.Name }}
      app.kubernetes.io/managed-by: {{.Release.Service }}
      app.kubernetes.io/component: pxc-backup-mongodb
  serviceName: pxc-backup-mongodb-headless
  podManagementPolicy: Parallel
  replicas: 3
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      {{- if and (eq $azureProxyEnabled true) (not (has "pxc-backup-mongodb" .Values.proxy.excludeAzureProxyList)) }}
      annotations:
        kubernetes.azure.com/no-http-proxy-vars: "true"
      {{- end }}
      labels:
        app.kubernetes.io/name: {{.Release.Name }}
        app.kubernetes.io/instance: {{.Release.Name }}
        app.kubernetes.io/managed-by: {{.Release.Service }}
        app.kubernetes.io/component: pxc-backup-mongodb
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              {{- if .Values.nodeAffinityLabel }}
              - key: {{ .Values.nodeAffinityLabel }}
                operator: Exists
              {{- else }}
              - key: pxbackup/enabled
                operator: NotIn
                values:
                - "false"
              {{- end }}
        podAntiAffinity:
          {{- if eq .Values.podAntiAffinity true }}
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                - key: app.kubernetes.io/component
                  operator: In
                  values:
                  - pxc-backup-mongodb
              topologyKey: kubernetes.io/hostname
          {{- else }}
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                  - key: app.kubernetes.io/component
                    operator: In
                    values:
                    - pxc-backup-mongodb
                topologyKey: kubernetes.io/hostname
          {{- end }}
      {{- if eq .Values.storkRequired true }}
      schedulerName: stork
      {{- end }}
      {{- if .Values.images.pullSecrets }}
      imagePullSecrets:
        {{- range $sec := .Values.images.pullSecrets }}
        - name: {{ $sec | quote }}
        {{- end }}
      {{- end }}
      serviceAccountName: pxc-backup-mongodb
      {{- if $isOpenshiftCluster}}
      {{- else }}
      securityContext:
{{ toYaml .Values.securityContext | indent 8 }}
      {{- end }}
      containers:
        - name: mongodb
          image: {{ printf "%s/%s/%s:%s" (default .Values.images.mongodbImage.registry .Values.images.registry) (default .Values.images.mongodbImage.repo .Values.images.repo) .Values.images.mongodbImage.imageName .Values.images.mongodbImage.tag }}
          imagePullPolicy: {{ .Values.images.pullPolicy }}
          command:
            - /scripts/setup.sh
          {{- if or (eq $azureProxyEnabled true) (.Values.proxy.httpProxy.noProxy) }}
          args:
            - export MONGODB_INITIAL_PRIMARY_HOST=pxc-backup-mongodb-0.$(K8S_SERVICE_NAME) && export MONGODB_ADVERTISED_HOSTNAME=$(MY_POD_NAME).$(K8S_SERVICE_NAME) && /scripts/setup.sh
          {{- end }}
          env:

          {{- include "serviceMesh.env" . | nindent 12 }}
            - name: MY_POD_IP
              valueFrom:
                fieldRef:
                  fieldPath: status.podIP
            - name: MY_POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: MY_POD_NAMESPACE
              valueFrom:
                fieldRef:
                  apiVersion: v1
                  fieldPath: metadata.namespace
            - name: K8S_SERVICE_NAME
              value: pxc-backup-mongodb-headless
            - name: MONGODB_INITIAL_PRIMARY_HOST
              value: pxc-backup-mongodb-0.$(K8S_SERVICE_NAME)
            - name: MONGODB_REPLICA_SET_NAME
              value: rs0
            - name: MONGODB_ADVERTISED_HOSTNAME
              value: $(MY_POD_NAME).$(K8S_SERVICE_NAME)
            - name: MONGODB_DATA_DIR
              value: /data/db
            - name: MONGODB_USERNAME
              valueFrom:
                secretKeyRef:
                  key: mongodb-username
                  name: pxc-backup-mongodb
            - name: MONGODB_DATABASE
              value: px-backup
            - name: MONGODB_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: mongodb-password
                  name: pxc-backup-mongodb
            - name: MONGODB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  key: mongodb-root-password
                  name: pxc-backup-mongodb
            - name: MONGODB_REPLICA_SET_KEY
              valueFrom:
                secretKeyRef:
                  key: mongodb-replica-set-key
                  name: pxc-backup-mongodb
            - name: MONGODB_CACHE_SIZE
              value: "{{ $mongoCacheSize }}"

            {{- if or (empty .Values.proxy.includeNoProxyList) (has "pxc-backup-mongodb" .Values.proxy.includeNoProxyList) }}
            {{- include "proxy.proxyEnv" . | nindent 12 }}
            {{- end }}
          ports:
            - containerPort: 27017
              name: mongodb
              protocol: TCP
          # Simple liveness probe
          livenessProbe:
            exec:
              command:
              - bash
              - -c
              - |
                mongosh --quiet --eval 'db.adminCommand("ping")' || exit 1
            failureThreshold: 6
            initialDelaySeconds: 600
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
          readinessProbe:
            exec:
              command:
              - bash
              - -c
              - |
                mongosh --quiet --eval 'db.hello().isWritablePrimary || db.hello().secondary' | grep -q 'true'
            failureThreshold: 6
            initialDelaySeconds: 60
            periodSeconds: 10
            timeoutSeconds: 5
          # Startup probe
          startupProbe:
            exec:
              command:
                - bash
                - -c
                - |
                  mongosh --quiet --eval 'db.adminCommand("ping")' > /dev/null 2>&1
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 5
            failureThreshold: 60
          volumeMounts:
            - mountPath: /data/db
              name: pxc-mongodb-data
            - mountPath: /scripts/setup.sh
              name: scripts
              subPath: setup.sh
          {{- if .Values.proxy.configSecretName }}
            - mountPath: /etc/ssl/certs/proxy-ca.pem
              subPath: proxy-ca.pem
              name: proxy-ca-volume
              readOnly: true
          {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
      {{- toYaml . | nindent 8 }}
      {{- end }}
      volumes:
        - name: scripts
          configMap:
            defaultMode: 493
            name: pxc-backup-mongodb-scripts
        {{- if eq $externalPersistentStorageEnabled false }}
        - name: pxc-mongodb-data
          emptyDir: {}
        {{- end }}
      {{- if .Values.proxy.configSecretName }}
        - name: proxy-ca-volume
          secret:
            items:
            - key: CA
              path: proxy-ca.pem
            optional: true
            secretName: {{ .Values.proxy.configSecretName }}
      {{- end }}
  {{- if eq $externalPersistentStorageEnabled true }}
  volumeClaimTemplates:
    - metadata:
        name: pxc-mongodb-data
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: {{ .Values.persistentStorage.mongodbVolumeSize }}
        {{- if .Values.persistentStorage.storageClassName }}
        storageClassName: {{ .Values.persistentStorage.storageClassName }}
        {{- end }}
  {{- end }}
{{- end -}}
